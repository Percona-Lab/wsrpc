// Code generated by protoc-gen-wsrpc. DO NOT EDIT.
// source: example/api/proto.proto

package api

import (
	"context"
	"log"

	"github.com/Percona-Lab/wsrpc"
	"github.com/golang/protobuf/proto"
	"github.com/pkg/errors"
)

// Client API for api.EchoService service

type EchoServiceClient interface {
	Echo(context.Context, *EchoRequest) (*EchoResponse, error)
}

type echoServiceClient struct {
	conn *wsrpc.Conn
}

func NewEchoServiceClient(conn *wsrpc.Conn) EchoServiceClient {
	return &echoServiceClient{conn}
}

func (c *echoServiceClient) Echo(ctx context.Context, req *EchoRequest) (*EchoResponse, error) {
	b, err := proto.Marshal(req)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to marshal protobuf message %T", req)
	}
	if b, err = c.conn.Invoke("Echo", b); err != nil {
		return nil, err
	}
	res := new(EchoResponse)
	if err = proto.Unmarshal(b, res); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal protobuf message to %T", res)
	}
	return res, nil
}

// Server API for api.EchoService service

type EchoServiceServer interface {
	Echo(context.Context, *EchoRequest) (*EchoResponse, error)
}

type EchoServiceDispatcher struct {
	conn   *wsrpc.Conn
	server EchoServiceServer
}

func NewEchoServiceDispatcher(conn *wsrpc.Conn, server EchoServiceServer) *EchoServiceDispatcher {
	return &EchoServiceDispatcher{conn, server}
}

func dispatchEcho(server interface{}, arg []byte) ([]byte, error) {
	req := new(EchoRequest)
	if err := proto.Unmarshal(arg, req); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal protobuf message to %T", req)
	}
	res, err := server.(EchoServiceServer).Echo(context.TODO(), req)
	if err != nil {
		return nil, err
	}
	b, err := proto.Marshal(res)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to marshal protobuf message %T", res)
	}
	return b, nil
}

var echoServiceDescription = &wsrpc.ServiceDesc{
	Methods: []wsrpc.ServiceMethod{
		{
			Name:   "Echo",
			Method: dispatchEcho,
		},
	},
}

func (d *EchoServiceDispatcher) Run(ctx context.Context) {
	for {
		message, err := d.conn.Read(ctx)
		if err != nil {
			log.Panic(err)
		}

		var found bool
		for _, method := range echoServiceDescription.Methods {
			if method.Name != message.Path {
				continue
			}

			res, err := method.Method(d.server, message.Arg)
			if err != nil {
				log.Panic(err)
			}

			message = &wsrpc.V1Message{
				V1MessageHeader: wsrpc.V1MessageHeader{
					StreamID: message.StreamID,
					PathLen:  uint8(len(message.Path)),
				},
				Path: message.Path,
				Arg:  res,
			}
			if err = d.conn.Write(ctx, message); err != nil {
				log.Panic(err)
			}

			found = true
			break
		}

		if !found {
			log.Panicf("unexpected path %q", message.Path)
		}
	}
}
